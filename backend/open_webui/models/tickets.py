import time
from typing import Optional
from enum import Enum

from open_webui.internal.db import Base, JSONField, get_db
from pydantic import BaseModel, ConfigDict
from sqlalchemy import BigInteger, Column, String, Text, Integer, Boolean, Index, or_


class TicketStatus(str, Enum):
    OPEN = "open"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    CLOSED = "closed"


class TicketPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    URGENT = "urgent"


class TicketCategory(str, Enum):
    BUG = "bug"
    FEATURE_REQUEST = "feature_request"
    GENERAL_INQUIRY = "general_inquiry"
    TECHNICAL_SUPPORT = "technical_support"
    OTHER = "other"


####################
# Ticket DB Schema
####################

class Ticket(Base):
    __tablename__ = "ticket"

    id = Column(String, primary_key=True)
    title = Column(String, nullable=False)
    description = Column(Text, nullable=False)
    status = Column(String, default=TicketStatus.OPEN)
    priority = Column(String, default=TicketPriority.MEDIUM)
    category = Column(String, default=TicketCategory.GENERAL_INQUIRY)
    
    # User who created the ticket
    user_id = Column(String, nullable=False)
    user_name = Column(String, nullable=False)
    user_email = Column(String, nullable=False)
    
    # Admin assigned to handle the ticket
    assigned_to = Column(String, nullable=True)
    assigned_to_name = Column(String, nullable=True)
    
    # Task assignment details
    task_requirements = Column(Text, nullable=True)  # Specific task requirements
    completion_criteria = Column(Text, nullable=True)  # What needs to be done to complete
    task_deadline = Column(BigInteger, nullable=True)  # Task deadline timestamp
    task_priority = Column(String, nullable=True)  # Task-specific priority
    
    # Delivery requirements
    required_files = Column(Text, nullable=True)  # Required file types (JSON string)
    required_text = Column(Text, nullable=True)  # Required text submission
    required_images = Column(Text, nullable=True)  # Required image specifications
    delivery_instructions = Column(Text, nullable=True)  # Delivery instructions
    
    # Task completion
    delivery_files = Column(JSONField, nullable=True)  # Submitted files
    delivery_text = Column(Text, nullable=True)  # Submitted text
    delivery_images = Column(JSONField, nullable=True)  # Submitted images
    completion_status = Column(String, nullable=True)  # pending, submitted, verified, rejected
    completion_notes = Column(Text, nullable=True)  # Completion notes
    
    # Verification details
    verification_score = Column(Integer, nullable=True)  # Verification score (0-100)
    verification_checklist = Column(JSONField, nullable=True)  # Verification checklist
    
    # Additional metadata
    attachments = Column(JSONField, nullable=True)  # List of file paths/URLs
    tags = Column(JSONField, nullable=True)  # List of tags
    comments = Column(JSONField, nullable=True)  # List of comments
    
    # AI generation metadata
    is_ai_generated = Column(Boolean, default=False)  # Whether ticket was generated by AI
    source_feedback_id = Column(String, nullable=True)  # ID of the feedback that triggered this ticket
    ai_analysis = Column(JSONField, nullable=True)  # AI analysis data
    
    # Timestamps
    created_at = Column(BigInteger)
    updated_at = Column(BigInteger)
    resolved_at = Column(BigInteger, nullable=True)
    
    # 添加索引以提高查询性能
    __table_args__ = (
        Index('idx_ticket_user_id', 'user_id'),
        Index('idx_ticket_assigned_to', 'assigned_to'),
        Index('idx_ticket_status', 'status'),
        Index('idx_ticket_priority', 'priority'),
        Index('idx_ticket_category', 'category'),
        Index('idx_ticket_created_at', 'created_at'),
        Index('idx_ticket_status_created', 'status', 'created_at'),
        Index('idx_ticket_user_created', 'user_id', 'created_at'),
    )


class TicketModel(BaseModel):
    id: str
    title: str
    description: str
    status: TicketStatus = TicketStatus.OPEN
    priority: TicketPriority = TicketPriority.MEDIUM
    category: TicketCategory = TicketCategory.GENERAL_INQUIRY
    
    user_id: str
    user_name: str
    user_email: str
    
    assigned_to: Optional[str] = None
    assigned_to_name: Optional[str] = None
    
    # Task assignment details
    task_requirements: Optional[str] = None
    completion_criteria: Optional[str] = None
    task_deadline: Optional[int] = None
    task_priority: Optional[str] = None
    
    # Delivery requirements
    required_files: Optional[str] = None
    required_text: Optional[str] = None
    required_images: Optional[str] = None
    delivery_instructions: Optional[str] = None
    
    # Task completion
    delivery_files: Optional[list] = None
    delivery_text: Optional[str] = None
    delivery_images: Optional[list] = None
    completion_status: Optional[str] = None
    completion_notes: Optional[str] = None
    
    # Verification details
    verification_score: Optional[int] = None
    verification_checklist: Optional[list] = None
    
    attachments: Optional[list] = None
    tags: Optional[list] = None
    comments: Optional[list] = None
    
    # AI generation metadata
    is_ai_generated: bool = False
    source_feedback_id: Optional[str] = None
    ai_analysis: Optional[dict] = None
    
    created_at: int
    updated_at: int
    resolved_at: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


####################
# Forms
####################

class CreateTicketForm(BaseModel):
    title: str
    description: str
    priority: TicketPriority = TicketPriority.MEDIUM
    category: TicketCategory = TicketCategory.GENERAL_INQUIRY
    attachments: Optional[list] = None
    tags: Optional[list] = None


class UpdateTicketForm(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    status: Optional[TicketStatus] = None
    priority: Optional[TicketPriority] = None
    category: Optional[TicketCategory] = None
    assigned_to: Optional[str] = None
    tags: Optional[list] = None


class AddCommentForm(BaseModel):
    content: str
    is_internal: bool = False  # Internal comments only visible to admins


class TicketListResponse(BaseModel):
    tickets: list[TicketModel]
    total: int


class TicketComment(BaseModel):
    id: str
    content: str
    author_id: str
    author_name: str
    is_internal: bool = False
    created_at: int


####################
# Database Operations
####################

class TicketsTable:
    def create_ticket(
        self,
        id: str,
        title: str,
        description: str,
        user_id: str,
        user_name: str,
        user_email: str,
        priority: TicketPriority = TicketPriority.MEDIUM,
        category: TicketCategory = TicketCategory.GENERAL_INQUIRY,
        attachments: Optional[list] = None,
        tags: Optional[list] = None,
        is_ai_generated: bool = False,
        source_feedback_id: Optional[str] = None,
        ai_analysis: Optional[dict] = None,
    ) -> Optional[TicketModel]:
        try:
            with get_db() as db:
                ticket = TicketModel(
                    **{
                        "id": id,
                        "title": title,
                        "description": description,
                        "status": TicketStatus.OPEN,
                        "priority": priority,
                        "category": category,
                        "user_id": user_id,
                        "user_name": user_name,
                        "user_email": user_email,
                        "attachments": attachments or [],
                        "tags": tags or [],
                        "comments": [],
                        "is_ai_generated": is_ai_generated,
                        "source_feedback_id": source_feedback_id,
                        "ai_analysis": ai_analysis,
                        "created_at": int(time.time()),
                        "updated_at": int(time.time()),
                    }
                )
                result = Ticket(**ticket.model_dump())
                db.add(result)
                db.commit()
                db.refresh(result)
                return ticket
        except Exception as e:
            print(f"Error creating ticket: {e}")
            return None

    def update_ticket_ai_analysis(self, ticket_id: str, ai_analysis: dict) -> bool:
        """更新工单的AI分析"""
        try:
            with get_db() as db:
                ticket = db.query(Ticket).filter(Ticket.id == ticket_id).first()
                if ticket:
                    ticket.ai_analysis = ai_analysis
                    ticket.updated_at = int(time.time())
                    db.commit()
                    return True
                return False
        except Exception as e:
            print(f"Error updating ticket AI analysis: {e}")
            return False

    def get_ticket_by_id(self, id: str) -> Optional[TicketModel]:
        try:
            print(f"Querying ticket with ID: {id}")
            with get_db() as db:
                ticket = db.query(Ticket).filter_by(id=id).first()
                print(f"Database query result: {ticket is not None}")
                if ticket:
                    print(f"Found ticket: {ticket.id}, title: {ticket.title}")
                    return TicketModel.model_validate(ticket)
                print(f"No ticket found with ID: {id}")
                return None
        except Exception as e:
            print(f"Error querying ticket {id}: {e}")
            return None

    def get_ticket_by_source_feedback_id(self, source_feedback_id: str) -> Optional[TicketModel]:
        """根据source_feedback_id查找工单"""
        try:
            with get_db() as db:
                ticket = db.query(Ticket).filter_by(source_feedback_id=source_feedback_id).first()
                if ticket:
                    return TicketModel.model_validate(ticket)
                return None
        except Exception:
            return None

    def get_tickets(
        self,
        user_id: Optional[str] = None,
        assigned_to: Optional[str] = None,
        status: Optional[TicketStatus] = None,
        priority: Optional[TicketPriority] = None,
        category: Optional[TicketCategory] = None,
        skip: Optional[int] = None,
        limit: Optional[int] = None,
    ) -> dict:
        try:
            with get_db() as db:
                # 构建基础查询
                query = db.query(Ticket)
                count_query = db.query(Ticket)

                # 应用过滤条件
                filters = []
                if user_id:
                    # 用户可以看到自己创建的工单和分配给自己的工单
                    filters.append(
                        or_(
                            Ticket.user_id == user_id,
                            Ticket.assigned_to == user_id
                        )
                    )
                if assigned_to:
                    filters.append(Ticket.assigned_to == assigned_to)
                if status:
                    filters.append(Ticket.status == status)
                if priority:
                    filters.append(Ticket.priority == priority)
                if category:
                    filters.append(Ticket.category == category)

                # 一次性应用所有过滤条件
                if filters:
                    query = query.filter(*filters)
                    count_query = count_query.filter(*filters)

                # 获取总数（优化：只在需要时计算）
                total = count_query.count()

                # 应用排序和分页
                query = query.order_by(Ticket.created_at.desc())
                
                if skip:
                    query = query.offset(skip)
                if limit:
                    query = query.limit(limit)

                tickets = query.all()
                return {
                    "tickets": [TicketModel.model_validate(ticket) for ticket in tickets],
                    "total": total,
                }
        except Exception as e:
            print(f"Error getting tickets: {e}")
            return {"tickets": [], "total": 0}

    def update_ticket(self, id: str, updates: dict) -> Optional[TicketModel]:
        try:
            with get_db() as db:
                updates["updated_at"] = int(time.time())
                
                # If status is being changed to resolved/closed, set resolved_at
                if updates.get("status") in [TicketStatus.RESOLVED, TicketStatus.CLOSED]:
                    updates["resolved_at"] = int(time.time())
                
                db.query(Ticket).filter_by(id=id).update(updates)
                db.commit()
                
                ticket = db.query(Ticket).filter_by(id=id).first()
                if ticket:
                    return TicketModel.model_validate(ticket)
                return None
        except Exception as e:
            print(f"Error updating ticket: {e}")
            return None

    def add_comment(self, ticket_id: str, comment: TicketComment) -> bool:
        try:
            with get_db() as db:
                ticket = db.query(Ticket).filter_by(id=ticket_id).first()
                if not ticket:
                    return False
                
                comments = ticket.comments or []
                comments.append(comment.model_dump())
                
                db.query(Ticket).filter_by(id=ticket_id).update({
                    "comments": comments,
                    "updated_at": int(time.time())
                })
                db.commit()
                return True
        except Exception as e:
            print(f"Error adding comment: {e}")
            return False

    def delete_ticket(self, id: str) -> bool:
        try:
            with get_db() as db:
                db.query(Ticket).filter_by(id=id).delete()
                db.commit()
                return True
        except Exception:
            return False

    def get_ticket_stats(self) -> dict:
        try:
            with get_db() as db:
                total = db.query(Ticket).count()
                open_count = db.query(Ticket).filter_by(status=TicketStatus.OPEN).count()
                in_progress_count = db.query(Ticket).filter_by(status=TicketStatus.IN_PROGRESS).count()
                resolved_count = db.query(Ticket).filter_by(status=TicketStatus.RESOLVED).count()
                closed_count = db.query(Ticket).filter_by(status=TicketStatus.CLOSED).count()
                
                # 添加部门完成工单统计
                department_stats = {}
                department_member_stats = {}
                from sqlalchemy import text
                from open_webui.models.groups import Groups
                from open_webui.models.users import Users
                
                # 获取所有权限组信息
                all_groups = Groups.get_groups()
                group_members = {}  # {group_name: [user_ids]}
                user_groups = {}    # {user_id: group_name}
                
                for group in all_groups:
                    group_members[group.name] = group.user_ids or []
                    for user_id in group.user_ids or []:
                        user_groups[user_id] = group.name
                
                # 查询按部门分组的完成工单数量
                result = db.execute(text("""
                    SELECT 
                        assigned_to as user_id,
                        COUNT(*) as completed_count
                    FROM ticket 
                    WHERE status IN ('resolved', 'closed') 
                        AND assigned_to IS NOT NULL 
                        AND assigned_to != ''
                    GROUP BY assigned_to
                    ORDER BY completed_count DESC
                """))
                
                user_completion_data = result.fetchall()
                
                # 按权限组重新组织数据
                for row in user_completion_data:
                    user_id = row[0]
                    count = row[1]
                    
                    # 获取用户名
                    user = Users.get_user_by_id(user_id)
                    username = user.name if user else user_id
                    
                    # 查找用户所属的权限组
                    group_name = user_groups.get(user_id)
                    if group_name:
                        if group_name not in department_stats:
                            department_stats[group_name] = 0
                            department_member_stats[group_name] = {}
                        
                        department_stats[group_name] += count
                        department_member_stats[group_name][username] = count
                    else:
                        # 如果用户不属于任何权限组，归类到"未分组"
                        if "未分组" not in department_stats:
                            department_stats["未分组"] = 0
                            department_member_stats["未分组"] = {}
                        
                        department_stats["未分组"] += count
                        department_member_stats["未分组"][username] = count
                
                return {
                    "total": total,
                    "open": open_count,
                    "in_progress": in_progress_count,
                    "resolved": resolved_count,
                    "closed": closed_count,
                    "department_stats": department_stats,
                    "department_member_stats": department_member_stats,
                }
        except Exception as e:
            print(f"Error getting ticket stats: {e}")
            return {
                "total": 0,
                "open": 0,
                "in_progress": 0,
                "resolved": 0,
                "closed": 0,
                "department_stats": {},
                "department_member_stats": {},
            }


Tickets = TicketsTable()


####################
# Task Assignment Forms
####################

class TaskAssignmentForm(BaseModel):
    assigned_to: str
    task_requirements: str  # 具体任务要求
    completion_criteria: str  # 完成标准
    task_deadline: Optional[int] = None  # 截止时间（时间戳）
    task_priority: Optional[str] = None  # 任务优先级
    reason: Optional[str] = None  # 分配原因


class TaskCompletionForm(BaseModel):
    completion_notes: str  # 完成说明
    completion_evidence: Optional[str] = None  # 完成证据（如链接、截图等）
    verification_required: bool = True  # 是否需要验证


class TaskVerificationForm(BaseModel):
    verified: bool  # 是否通过验证
    verification_notes: Optional[str] = None  # 验证说明
    feedback: Optional[str] = None  # 反馈意见
